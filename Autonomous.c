#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    topRitePot,     sensorPotentiometer)
#pragma config(Sensor, in2,    topLeftPot,     sensorPotentiometer)
#pragma config(Sensor, in3,    lowRitePot,     sensorPotentiometer)
#pragma config(Sensor, in4,    lowLeftPot,     sensorPotentiometer)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           drvRiteMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           drvLeftMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           topRiteMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           topLeftMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lowRiteMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lowLeftMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// one rev = 627.2 sensor value
// 2.75pi = 8.64 inch per revolution


int loopcontroller=0;
int loopcontroller2=0;
int rightEnc;
int leftEnc;


task main()
{ SensorType[gyro] = sensorNone;
  wait1Msec(1000);
  //Reconfigure in5 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[gyro] = sensorGyro;
  wait1Msec(2000);

rightEnc = SensorValue(rightEncoder);
leftEnc = SensorValue(leftEncoder);


while(loopcontroller<=1){
//go and grab cube
waitInMilliseconds(100);

//----------------------------  goforward
startMotor(drvRiteMotr,63);
startMotor(drvLeftMotr,63);

if(abs(SensorValue(rightEncoder))>(abs(rightEnc)+1000))
	 {
	   stopMotor(drvRiteMotr); if(loopcontroller<=1){loopcontroller++;}
   }
if(abs(SensorValue(leftEncoder))>(abs(leftEnc)+1000))
	 {
	   stopMotor(drvLeftMotr); if(loopcontroller<=1){loopcontroller++;}
	 }
} //while loop ends
//----------------------------- go forward

//*********************************************************************

// intake the cube

//*********************************************************************

//----------------------------- turn 180 degrees
while(abs(0-SensorValue[gyro]) < 1600)
  {
  	pointTurn(right,63);
  }
//----------------------------- turn 180 degrees

//*********************************************************************

//----------------------------- go back to floorgoal
rightEnc=SensorValue(rightEncoder); //decrease when forward
leftEnc=SensorValue(leftEncoder); //increaes when forward

  while(loopcontroller2<=2){

waitInMilliseconds(100);
startMotor(drvRiteMotr,63);
startMotor(drvLeftMotr,63);

if(abs(SensorValue(rightEncoder))>(abs(rightEnc)+1000))
	 {
	   stopMotor(drvRiteMotr); if(loopcontroller<=2){loopcontroller2++;}
   }
if(abs(SensorValue(leftEncoder))>(abs(leftEnc)+1000))
	 {
	   stopMotor(drvLeftMotr); if(loopcontroller<=2){loopcontroller2++;}
	 }
} //while loop ends
//----------------------------- go back to floorgoal

//*********************************************************************

//----------------------------- turn to section
while(abs(0-SensorValue[gyro]) < 300)
  {
  	pointTurn(right,63);
  }
//----------------------------- turn to section

//*********************************************************************

//grab the section

//*********************************************************************

//----------------------------- turn to Skyrise
while(abs(0-SensorValue[gyro]) < 900)
  {
  	pointTurn(left,63);
  }
//----------------------------- turn to skyrise

//*********************************************************************

//insert skyrise

//insert cubes


} // main ends
