#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    topRitePot,     sensorPotentiometer)
#pragma config(Sensor, in2,    topLeftPot,     sensorPotentiometer)
#pragma config(Sensor, in3,    lowRitePot,     sensorPotentiometer)
#pragma config(Sensor, in4,    lowLeftPot,     sensorPotentiometer)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           drvRiteMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           drvLeftMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           topRiteMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           topLeftMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lowRiteMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lowLeftMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           intake2,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// one rev = 627.2 sensor value
// 2.75pi = 8.64 inch per revolution


int loopcontroller=0;
int loopcontroller2=0;
int rightEnc;
int leftEnc;


task main()
{
	forward(leftEnc);
	SensorType[gyro] = sensorNone;
  wait1Msec(1000);
  SensorType[gyro] = sensorGyro;
  wait1Msec(2000);

rightEnc = SensorValue(rightEncoder);
leftEnc = SensorValue(leftEncoder);

int autonomous=0; //0 = one section, one cube; 1 = grab a cube and put it in nearest post

//ADD CODE HERE --- set claw to be parallel to the grounds

if(autonomous==0){
// ----------------------------- turns to the auto loader
while(abs(0+SensorValue[gyro]) < 290)
  {
  	pointTurn(right,63);
  }
//----------------------------- turns to the auto loader
//*********************************************************************

//----------------------------- go foward
rightEnc=SensorValue(rightEncoder);
leftEnc=SensorValue(leftEncoder);

  while(loopcontroller2<=2){

waitInMilliseconds(100);
startMotor(drvRiteMotr,63);
startMotor(drvLeftMotr,63);

if(abs(SensorValue(rightEncoder))>(abs(rightEnc)+240))
	 {
	   stopMotor(drvRiteMotr); if(loopcontroller<=2){loopcontroller2++;}
   }
if(abs(SensorValue(leftEncoder))>(abs(leftEnc)+240))
	 {
	   stopMotor(drvLeftMotr); if(loopcontroller<=2){loopcontroller2++;}
	 }
} //while loop ends
//----------------------------- go forward

//*********************************************************************

//get section

//lift its claw
startMotor(topRiteMotr,63);
startMotor(topLeftMotr,63);
wait(0.4);
startMotor(topRiteMotr,13);
startMotor(topLeftMotr,13);

//goes forward
forward(63);
wait(0.7);
stop();

//grabs the section
startMotor(claw,63);
wait(1);
startMotor(claw,40);


//takes the section out of the autoloader
backward(63);
wait(0.5);
stop();


startMotor(topRiteMotr,80);
startMotor(topLeftMotr,80);
wait(0.5);
startMotor(topRiteMotr,13);
startMotor(topLeftMotr,13);

startMotor(intake,10);
//*********************************************************************

//backs away from the autoloader
backward(63);
wait(1.5);
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

//----------------------------- turns direction to skyrise
while(abs(0+SensorValue[gyro]) < 320)
  {
  	pointTurn(left,63);
  }


//*********************************************************************

  //goes to the skyrise
 forward(63);
 wait(0.8);
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

// lowers the lift
startMotor(topLeftMotr,-80);
  startMotor(topRiteMotr,-80	);
  wait(0.5);
  startMotor(topLeftMotr,12);
  startMotor(topRiteMotr,12);

//release the section
  wait(0.3);
  startMotor(claw, -80);
  wait(0.5);
  stop();


//release the cube
  startMotor(intake,63);
  startMotor(intake2,63);
  wait(2);
  stopMotor(intake);
  stopMotor(intake2);
}
} // main ends
