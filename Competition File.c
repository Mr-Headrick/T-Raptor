#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           drvRiteMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           drvLeftMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           topRiteMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           topLeftMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lowRiteMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lowLeftMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int loopcontroller=0;
int loopcontroller2=0;
int rightEnc;
int leftEnc;

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  startMotor(claw,-63);
  wait(2);
  stopMotor(claw);

  nMotorEncoder[drvRiteMotr] = 0;
	nMotorEncoder[drvLeftMotr] = 0;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{//Reconfigure in5 as a Gyro sensor and allow time for ROBOTC to calibrate it

		SensorType[gyro] = sensorNone;
  wait1Msec(1000);
  SensorType[gyro] = sensorGyro;
  wait1Msec(2000);

rightEnc = SensorValue(rightEncoder);
leftEnc = SensorValue(leftEncoder);

int autonomous=0; //0 = one section, one cube; 1 = grab a cube and put it in nearest post

//ADD CODE HERE --- set claw to be parallel to the grounds

if(autonomous==0){
// ----------------------------- turns to the auto loader
while(abs(0+SensorValue[gyro]) < 290)
  {
  	pointTurn(right,63);
  }
//----------------------------- turns to the auto loader
//*********************************************************************

//----------------------------- go foward
rightEnc=SensorValue(rightEncoder); //decrease when forward
leftEnc=SensorValue(leftEncoder); //increaes when forward

  while(loopcontroller2<=2){

waitInMilliseconds(100);
startMotor(drvRiteMotr,63);
startMotor(drvLeftMotr,63);

if(abs(SensorValue(rightEncoder))>(abs(rightEnc)+230))
	 {
	   stopMotor(drvRiteMotr); if(loopcontroller<=2){loopcontroller2++;}
   }
if(abs(SensorValue(leftEncoder))>(abs(leftEnc)+230))
	 {
	   stopMotor(drvLeftMotr); if(loopcontroller<=2){loopcontroller2++;}
	 }
} //while loop ends
//----------------------------- go forward

//*********************************************************************

//get section

//lift its claw
startMotor(topRiteMotr,63);
startMotor(topLeftMotr,63);
wait(0.4);
startMotor(topRiteMotr,13);
startMotor(topLeftMotr,13);

//goes forward
forward(63);
wait(0.8);
stop();

//grabs the section
startMotor(claw,63);
wait(1);
startMotor(claw,40);


//takes the section out of the autoloader
backward(63);
wait(0.5);
stop();


startMotor(topRiteMotr,80);
startMotor(topLeftMotr,80);
wait(0.5);
startMotor(topRiteMotr,13);
startMotor(topLeftMotr,13);

startMotor(intake,10);
//*********************************************************************

//backs away from the autoloader
backward(63);
wait(1.5);
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

//----------------------------- turns direction to skyrise
while(abs(0+SensorValue[gyro]) < 300)
  {
  	pointTurn(left,63);
  }


//*********************************************************************

  //goes to the skyrise
 forward(63);
 wait(0.6);
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

// lowers the lift
startMotor(topLeftMotr,-80);
  startMotor(topRiteMotr,-80	);
  wait(0.5);
  startMotor(topLeftMotr,12);
  startMotor(topRiteMotr,12);

//release the section
  wait(0.3);
  startMotor(claw, -80);
  wait(0.5);
  stop();


//release the cube
  startMotor(intake,63);
  startMotor(intake2,63);
  wait(2);
  stopMotor(intake);
  stopMotor(intake2);
}
else if(autonomous==1){
//ADD THE OTHER AUTONOMOUS CODE
}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
  int buffer = 61;
  int fastSpd = 100;
  int spd = 63;
  int slowSpd = 52;
  int stopSpd = 12;

task usercontrol()
{
	// User control code here, inside the
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.

clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	displayLCDCenteredString(0,"Hi! I'm Freddy!");
	wait1Msec(500);
  while(1 == 1)
  {
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //Upper Lift Control

  if(vexRT[Btn6U] == 1 && vexRT[Btn6D] == 1){

}
    else if(vexRT[Btn6U] == 1 && vexRT[Btn6D] == 0)
    {
    	   motor[topRiteMotr] = spd+20;
         motor[topLeftMotr] = spd+20;
 /*     if(SensorValue(topRitePot)>SensorValue(topLeftPot)+buffer){
         motor[topRiteMotr] = slowSpd;
         motor[topLeftMotr] = fastSpd;}
      else if(SensorValue(topLeftPot)>SensorValue(topRitePot)+buffer){
         motor[topLeftMotr] = slowSpd;
         motor[topRiteMotr] = fastSpd;}
      else {
         motor[topRiteMotr] = spd;
         motor[topLeftMotr] = spd;} */
    }
    else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1)
    {
    	   motor[topRiteMotr] = -slowSpd;
         motor[topLeftMotr] = -slowSpd;
    }
    else
    {
         motor[topRiteMotr] = stopSpd;
         motor[topLeftMotr] = stopSpd;
    }


    //Lower Lift Control

    if(vexRT[Btn5U] == 1)
    {
    	   motor[lowRiteMotr] = fastSpd;
         motor[lowLeftMotr] = fastSpd;
         /*
      if(SensorValue(lowRitePot)>SensorValue(lowLeftPot)+buffer){
         motor[lowRiteMotr] = slowSpd;
         motor[lowLeftMotr] = fastSpd;}
      else if(SensorValue(lowLeftPot)>SensorValue(lowRitePot)+buffer){
         motor[lowLeftMotr] = slowSpd;
         motor[lowRiteMotr] = fastSpd;}
      else {
         motor[lowRiteMotr] = spd;
         motor[lowLeftMotr] = spd;}*/
    }
    else if(vexRT[Btn5D] == 1)
    {    motor[lowRiteMotr] = -fastSpd;
         motor[lowLeftMotr] = -fastSpd;
    }
    else
    {
         motor[lowRiteMotr] = stopSpd;
         motor[lowLeftMotr] = stopSpd;
    }
//+++++++++++++++++++++++++++++++++++++++++++++| DRIVE |+++++++++++++++++++++++++++++++++++++++++++++
    motor[drvLeftMotr]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // (y + x)/2
    motor[drvRiteMotr] = (vexRT[Ch2] - vexRT[Ch1])/2;  // (y - x)/2
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 if(vexRT[Btn7L]==1)      {
  motor[intake]= -63;
  motor[intake2]=-63;

  }
  else if(vexRT[Btn7D]==1){
  motor[intake]= 63;
  motor[intake2]=63;

  }
  else{motor[intake]=0;motor[intake2]=0;}

  if(vexRT[Btn8U]==1)      {
  motor[lowRiteMotr]= spd;}
  else if(vexRT[Btn7U]==1){
  motor[lowLeftMotr]= spd; }


  if(vexRT[Btn8R]==1){
    	motor[claw]=63;}
  else if(vexRT[Btn8D]==1){
  	  motor[claw]=-63;}
  else
  	{motor[claw]=0;}
	}

  displayLCDString(0,0,"RE:"); displayLCDNumber(0,3,SensorValue(rightEncoder));
  displayLCDString(1,0,"LE:"); displayLCDNumber(1,3,SensorValue(leftEncoder));
}
