#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in5,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           drvRiteMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           drvLeftMotr,   tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           topRiteMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           topLeftMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lowRiteMotr,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lowLeftMotr,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int rightEnc;
int leftEnc;
int loopcontroller=0;
int loopcontroller2=0;
int buffer = 61;
  int fastSpd = 100;
  int spd = 63;
  int slowSpd = 52;
  int stopSpd = 15;
  int auto=0;

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;
  startMotor(claw,-100);
  wait(1.5);
  stopMotor(claw);

  startMotor(topLeftMotr,-80);
  startMotor(topRiteMotr,-80);
  wait(0.3);
  stopMotor(topLeftMotr);
  stopMotor(topRiteMotr);

  nMotorEncoder[drvRiteMotr] = 0;
	nMotorEncoder[drvLeftMotr] = 0;



	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{


SensorType[gyro] = sensorNone;
  wait1Msec(500);
  //Reconfigure in5 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[gyro] = sensorGyro;
  wait1Msec(1000);


rightEnc = SensorValue(rightEncoder);
leftEnc = SensorValue(leftEncoder);


//0 = one section, one cube; 1 = grab a cube and put it in nearest post

//ADD CODE HERE --- set claw to be parallel to the grounds

if(auto==0){

startMotor(intake,-80);
startMotor(intake2,-80);
wait(0.3);
stopMotor(intake);
stopMotor(intake2);

  startMotor(claw,-100);
  wait(0.2);
  stopMotor(claw);

  //goforward
  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
  wait(0.5);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);

  //gobackward

  SensorValue[rightEncoder]=0;
  startMotor(drvLeftMotr,-100);
  startMotor(drvRiteMotr,-100);
  untilEncoderCounts(-100,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

   wait(0.1);

while(SensorValue[gyro]> -100)
  {
  	pointTurn(right,90);
  }

  wait(0.1);

  SensorValue[rightEncoder]=0;
  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
  untilEncoderCounts(120,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);
 //turn to autoloader
while(SensorValue[gyro] < 250)
  {
  	pointTurn(left,90);
  }
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

 wait(0.1);

 //back up little bit
 SensorValue[rightEncoder]=0;

  startMotor(drvLeftMotr,-90);
  startMotor(drvRiteMotr,-90);
  untilEncoderCounts(100,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

   wait(0.1);



  startMotor(topLeftMotr,spd+10);
  startMotor(topRiteMotr,spd+10);
  wait(0.15);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);

  wait(0.1);


  SensorValue[rightEncoder]=0;
  startMotor(drvLeftMotr,80);
  startMotor(drvRiteMotr,80);
  wait(0.6);
   stopMotor(drvLeftMotr);
   stopMotor(drvRiteMotr);

  wait(0.1);

  startMotor(claw,100);
  wait(1);
  startMotor(claw,0);

  wait(0.1);

 startMotor(drvLeftMotr,-90);
  startMotor(drvRiteMotr,-90);
  wait(0.2);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  startMotor(topLeftMotr,spd+20);
  startMotor(topRiteMotr,spd+20);
  wait(0.3);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);


  SensorValue[rightEnc]=0;
  startMotor(drvLeftMotr,-90);
  startMotor(drvRiteMotr,-90);
  untilEncoderCounts(-300,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  while(SensorValue[gyro] < 270)
  {
  	pointTurn(right,90);
  }

  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);

  SensorValue[leftEncoder]=0;

   while(SensorValue[gyro] > -60)
  {
  	pointTurn(right,90);
  }

  wait(0.1);

  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
  wait(0.18);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);



    startMotor(intake,-100);
  startMotor(intake2,-100);
  wait(0.1);
  stopMotor(intake);
  stopMotor(intake2);

  wait(0.5);

   startMotor(topLeftMotr,-spd+20);
  startMotor(topRiteMotr,-spd+20);
  wait(0.3);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);

  wait(0.5);



  startMotor(claw,-100);
  wait(0.3);
  stopMotor(claw);

 startMotor(drvLeftMotr,-100);
  startMotor(drvRiteMotr,-100);
  wait(0.4);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

}

else if(auto == 1){
	waitInMilliseconds(10);

startMotor(intake,-80);
startMotor(intake2,-80);
wait(0.3);
stopMotor(intake);
stopMotor(intake2);

	  startMotor(claw,-100);
  wait(0.2);
  stopMotor(claw);

  //goforward
  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
  wait(0.5);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);

  //gobackward


  startMotor(drvLeftMotr,-100);
  startMotor(drvRiteMotr,-100);
  untilEncoderCounts(400,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

   wait(0.1);

while(SensorValue[gyro] < 100)
  {
  	pointTurn(left,90);
  }

  wait(0.1);

  SensorValue[rightEncoder]=0;
  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
  untilEncoderCounts(120,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);
 //turn to autoloader
while(SensorValue[gyro] > -270)
  {
  	pointTurn(right,90);
  }
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

 wait(0.1);

 //back up little bit
 SensorValue[rightEncoder]=0;

  startMotor(drvLeftMotr,-90);
  startMotor(drvRiteMotr,-90);
  untilEncoderCounts(100,rightEncoder);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

   wait(0.1);


  startMotor(topLeftMotr,spd+10);
  startMotor(topRiteMotr,spd+10);
  wait(0.15);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);

  wait(0.1);


  SensorValue[rightEncoder]=0;
  startMotor(drvLeftMotr,100);
  startMotor(drvRiteMotr,100);
 wait(0.7);
   stopMotor(drvLeftMotr);
   stopMotor(drvRiteMotr);

  wait(0.1);

  startMotor(claw,100);
  wait(1);
  startMotor(claw,0);

  wait(0.1);

 startMotor(drvLeftMotr,-90);
  startMotor(drvRiteMotr,-90);
  wait(0.2);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  startMotor(topLeftMotr,spd+20);
  startMotor(topRiteMotr,spd+20);
  wait(0.3);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);




  while(SensorValue[gyro] < 170)
  {
  	pointTurn(left,90);
  }

  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);

  SensorValue[leftEncoder]=0;


  wait(0.1);

   while(SensorValue[gyro] < -60)
  {
  	pointTurn(left,90);
  }

  wait(0.1);

  startMotor(drvLeftMotr,80);
  startMotor(drvRiteMotr,80);
  wait(0.1);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);

  wait(0.1);



    startMotor(intake,-100);
  startMotor(intake2,-100);
  wait(0.1);
  stopMotor(intake);
  stopMotor(intake2);

  wait(0.5);

   startMotor(topLeftMotr,-spd+20);
  startMotor(topRiteMotr,-spd+20);
  wait(0.5);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);

  wait(1);



  startMotor(claw,-100);
  wait(0.3);
  stopMotor(claw);

 startMotor(drvLeftMotr,-100);
  startMotor(drvRiteMotr,-100);
  wait(0.4);
  stopMotor(drvLeftMotr);
  stopMotor(drvRiteMotr);


}

else if(auto==2){
//right Enc normal, left Enc opposite

while(SensorValue[gyro] >-200){
pointTurn(right,90);
}
stopMotor(drvLeftMotr);
stopMotor(drvRiteMotr);

wait(0.1);

 startMotor(topLeftMotr,spd+20);
  startMotor(topRiteMotr,spd+20);
  wait(0.5);
  startMotor(topLeftMotr,stopSpd);
  startMotor(topRiteMotr,stopSpd);

    startMotor(intake,100);
startMotor(intake2,100);
wait(2);
stopMotor(intake);
stopMotor(intake2);

wait(0.1);

SensorValue[rightEncoder]=0;
 startMotor(drvRiteMotr,-spd+20);
  startMotor(drvLeftMotr,-spd+20);
 untilEncoderCounts(-200,rightEncoder);
  stopMotor(drvRiteMotr);
  stopMotor(drvLeftMotr);

  wait(0.1);

  while(SensorValue[gyro] >-900){
pointTurn(right,90);
}

}


}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


task usercontrol()
{
	// User control code here, inside the
	  // This is the main execution loop for the user control program. Each time through the loop
	  // your program should update motor + servo values based on feedback from the joysticks.
clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	displayLCDString(0,0,"Hello I'm Freddy!");
	wait1Msec(500);

  while(1 == 1)
  {
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    //Upper Lift Control

  if(vexRT[Btn6U] == 1 && vexRT[Btn6D] == 1){

}
    else if(vexRT[Btn6U] == 1 && vexRT[Btn6D] == 0)
    {
    	   motor[topRiteMotr] = 100;
         motor[topLeftMotr] = 100;
 /*     if(SensorValue(topRitePot)>SensorValue(topLeftPot)+buffer){
         motor[topRiteMotr] = slowSpd;
         motor[topLeftMotr] = fastSpd;}
      else if(SensorValue(topLeftPot)>SensorValue(topRitePot)+buffer){
         motor[topLeftMotr] = slowSpd;
         motor[topRiteMotr] = fastSpd;}
      else {
         motor[topRiteMotr] = spd;
         motor[topLeftMotr] = spd;} */
    }
    else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1)
    {
    	   motor[topRiteMotr] = -100;
         motor[topLeftMotr] = -100;
    }
    else
    {
         motor[topRiteMotr] = 9;
         motor[topLeftMotr] = 8;
    }


    //Lower Lift Control

    if(vexRT[Btn5U] == 1)
    {
    	   motor[lowRiteMotr] = 120;
         motor[lowLeftMotr] = 120;


         /*
      if(SensorValue(lowRitePot)>SensorValue(lowLeftPot)+buffer){
         motor[lowRiteMotr] = slowSpd;
         motor[lowLeftMotr] = fastSpd;}
      else if(SensorValue(lowLeftPot)>SensorValue(lowRitePot)+buffer){
         motor[lowLeftMotr] = slowSpd;
         motor[lowRiteMotr] = fastSpd;}
      else {
         motor[lowRiteMotr] = spd;
         motor[lowLeftMotr] = spd;}*/
    }
    else if(vexRT[Btn5D] == 1)
    {    motor[lowRiteMotr] = -100;
         motor[lowLeftMotr] = -100;
              wait(0.4);
           stopMotor(lowRiteMotr);
         stopMotor(lowLeftMotr);
    }
    else
    {
         motor[lowRiteMotr] = stopSpd;
         motor[lowLeftMotr] = stopSpd;
    }
//+++++++++++++++++++++++++++++++++++++++++++++| DRIVE |+++++++++++++++++++++++++++++++++++++++++++++
    motor[drvLeftMotr]  = vexRT[Ch3];   // Left Joystick Y value
    motor[drvRiteMotr] = vexRT[Ch2];
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 if(vexRT[Btn7L]==1)      {
  motor[intake]= -63;
  motor[intake2]=-63;

  }
  else if(vexRT[Btn7D]==1){
  motor[intake]= 63;
  motor[intake2]=63;

  }
  else{motor[intake]=0;motor[intake2]=0;}

  if(vexRT[Btn8U]==1)      {
  motor[lowRiteMotr]= 100;}
  else if(vexRT[Btn7U]==1){
  motor[lowLeftMotr]= 100; }


  if(vexRT[Btn8R]==1){
    	motor[claw]=80;}
  else if(vexRT[Btn8D]==1){
  	  motor[claw]=-80;}
  else
  	{motor[claw]=0;}


if(nLCDButtons==1){auto=0;
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	displayLCDString(0,0,"Blue Team Section");
	wait1Msec(500);}
else if(nLCDButtons==2){auto=1;
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	displayLCDString(0,0,"Red Team Section");
	wait1Msec(500);
}
else if(nLCDButtons==4){auto=2;
clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	displayLCDString(0,0,"Blue Team Cube");
	wait1Msec(500);
}
	}




}
